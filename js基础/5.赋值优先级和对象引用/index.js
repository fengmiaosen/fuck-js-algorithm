var a = { n: 1 };
var b = a;

a.x = a = { n: 2 };

console.log(a.x)
console.log(b)
console.log(b.x)

//参考 https://muyiy.cn/question/js/53.html
// 这个问题考察的知识点主要有以下这些：

// . 的优先级高于 = 的优先级
// = 具有右结合性
// （执行的方向是从右往左，先执行 = 右边的表达式，然后把结果赋值给 = 左边的表达式，从这里可以得出 = 属于二元操作符），多个 = 的执行过程，可以类比成"递归"的过程

/**
 这是一个连续赋值表达式，需要理解JavaScript的赋值优先级和执行顺序：

1. 1.
   运算符优先级 ：成员访问 . 的优先级高于赋值 =
2. 2.
   赋值顺序 ：赋值运算符是右结合的，从右到左执行
执行步骤：

1. 1.
   第一步 ：解析 a.x
   
   - 此时 a 指向 { n: 1 }
   - a.x 表示要在这个对象上添加属性 x
   - 重要：这里记住了对象的引用位置
2. 2.
   第二步 ：执行右侧赋值 a = { n: 2 }
   
   - 创建新对象 { n: 2 }
   - a 现在指向新对象 { n: 2 }
   - 但 b 仍然指向原来的对象 { n: 1 }
3. 3.
   第三步 ：执行左侧赋值 a.x = { n: 2 }
   
   - 这里的 a.x 是在第一步解析时确定的
   - 它指向的是 原来的对象 （现在 b 指向的对象）
   - 所以在原对象上添加属性 x ，值为 { n: 2 }
最终状态：

- a 指向新对象 { n: 2 }
- b 指向原对象，现在变成了 { n: 1, x: { n: 2 } }
- 原对象的 x 属性指向 a 当前指向的对象
输出解释：

1. 1.
   console.log(a.x) → undefined （新对象 { n: 2 } 没有 x 属性）
2. 2.
   console.log(b) → { n: 1, x: { n: 2 } } （原对象被添加了 x 属性）
3. 3.
   console.log(b.x) → { n: 2 } （原对象的 x 属性值）
### 关键知识点
1. 1.
   运算符优先级 ：成员访问 . 优先级高于赋值 =
2. 2.
   对象引用 ：变量存储的是对象的引用，不是对象本身
3. 3.
   赋值时机 ：属性访问在赋值执行前就已经确定了目标对象
4. 4.
   连续赋值 ：从右到左执行，但左侧的属性访问在开始时就确定了目标
 */