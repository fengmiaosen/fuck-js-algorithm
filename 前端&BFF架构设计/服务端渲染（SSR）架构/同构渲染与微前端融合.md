# 同构渲染（SSR）与微前端融合实践指南

## 融合目标

- 保留同构渲染优势：首屏 SSR、良好 SEO、统一路由与数据获取
- 保留微前端优势：团队自治、独立构建部署、技术栈灵活
- 解决核心难点：跨应用 SSR 组合、Hydration 一致性、共享会话与降级策略

## 融合模式

- 路由级组合：不同路径交由不同微应用 SSR 输出，边界清晰、隔离强
- 片段级组合：在同一 SSR 页面内引入远程组件进行同构渲染，适合门户与仪表盘
- 岛屿架构：Host SSR 外壳，微前端以客户端组件挂载，兼容性最好、SSR 成本最低，例如：云控制台等场景
- 纯客户端兜底：当远程不可用或不支持 SSR 时动态降级

## 推荐方案

- React/Next.js 优先：Next.js Host + Module Federation（服务端与客户端双端）做片段级同构
- 跨技术栈通用：Web Components + 岛屿架构，Host SSR 外壳，远程在客户端挂载
- 大型多域：路由级代理组合（Next 重写/反向代理），各微应用独立 SSR

## 方案一：Next.js + Module Federation（同构组件级组合）

### 适用场景

- React 生态、需要在同一 SSR 页面中组合多个微组件
- 微应用均可产出 Node 端可加载的服务端入口与浏览器入口

### 关键点

- Host 与 Remote 都使用 Module Federation，`shared` 将 `react`、`react-dom` 设为单例
- Host 在 Node 运行时进行服务端联邦加载，客户端进行二次加载并 Hydration
- 远程产物区分 server/client 入口，CDN 发布并版本化

### Host 配置示例

```js
const { ModuleFederationPlugin } = require('webpack').container

module.exports = {
  webpack: (config, { isServer }) => {
    config.plugins.push(
      new ModuleFederationPlugin({
        name: 'host',
        remotes: {
          remote: isServer
            ? 'remote@https://cdn.example.com/server/remoteEntry.js'
            : 'remote@https://cdn.example.com/client/remoteEntry.js'
        },
        shared: {
          react: { singleton: true, eager: false, requiredVersion: false },
          'react-dom': { singleton: true, eager: false, requiredVersion: false }
        }
      })
    )
    return config
  }
}
```

### 页面使用示例（Pages Router）

```tsx
import dynamic from 'next/dynamic'

const RemoteButton = dynamic(() => import('remote/Button'), { ssr: true })

export default function Page(props) {
  return <RemoteButton {...props} />
}

export async function getServerSideProps(ctx) {
  const token = ctx.req.cookies['session']
  const [hostData, remoteData] = await Promise.all([
    fetch('https://api.example.com/host', {
      headers: { cookie: ctx.req.headers.cookie ?? '' }
    }).then(r => r.json()),
    fetch('https://api.example.com/remote', {
      headers: { cookie: ctx.req.headers.cookie ?? '' }
    }).then(r => r.json())
  ])
  return { props: { hostData, remoteData, token } }
}
```

### Remote 应用暴露组件示例

```tsx
export default function Button(props) {
  return <button>{props.text}</button>
}
```

### 注意事项

- App Router + Server Components 的跨应用联邦需专用插件支持，优先使用 Node 运行时
- Edge Runtime 对联邦不友好，尽量走 Node SSR；必要时边缘路由改为岛屿架构或路由级组合
- 联邦加载超时要有占位与兜底，客户端再尝试加载远程

## 方案二：Web Components 岛屿架构（通用技术栈）

### 客户端挂载示例

```tsx
export default function Page() {
  return (
    <>
      <script src="https://cdn.example.com/remote-widget.js"></script>
      <remote-widget data-user="u1" />
    </>
  )
}
```

### 备注

- 可配合自定义元素的 SSR（如 Lit SSR）实现部分片段 SSR，但复杂度高、生态不如 React 稳定
- 对 SEO 要求有限或远程不支持 SSR 时优先采用

## 方案三：路由级组合（独立 SSR 应用）

### Next 重写与代理示例

```js
module.exports = {
  async rewrites() {
    return [
      { source: '/shop/:path*', destination: 'https://shop.example.com/:path*' },
      { source: '/account/:path*', destination: 'https://account.example.com/:path*' }
    ]
  }
}
```

### 会话共享

- 使用同域 Cookie 或统一认证中心，实现多个域的登录态一致
- 统一 BFF 透传 Cookie，避免跨域认证复杂度

## 数据与会话

- 统一 BFF：Host 在 SSR 统一取数，远程组件通过 props 获得数据，避免跨应用共享全局状态
- Cookie 透传：在 SSR 请求远程或 BFF 时带上 `cookie`，保持登录态一致
- 合约优先：为远程组件定义稳定的 props 契约和版本管理，避免耦合远程内部状态

## 样式与资源

- 样式隔离：优先使用 CSS Modules、CSS-in-JS 局部作用域，避免全局样式污染
- 资源共享：Module Federation `shared` 控制版本与单例，避免多 React 副本导致 Hydration 失败
- 产物版本化：CDN 路径携带版本或生成 `manifest.json` 做动态路由

## 降级与容灾

- SSR 超时：远程组件加载超时渲染占位或回退本地实现
- 客户端兜底：SSR 渲染占位，客户端尝试加载远程，失败则记录埋点并保持占位
- 观测监控：对远程加载时间、失败率、版本分布、Hydration 错误进行监控与告警

## 性能与限制

- Streaming SSR：React 18 Suspense 流式渲染可缩短 TTFB，但远程组件需兼容
- 边缘限制：Module Federation 在 Edge Runtime 受限，优先 Node SSR；边缘路由用岛屿或路由级组合
- 打包体积：慎用 `eager`，通过 `shared` 去重；必要时按路由拆分远程

## 实施清单

- 选择组合模式（路由级、片段级、岛屿）与运行时（Node、Edge）
- 标准化远程产物发布流程（server/client 双入口、版本化、CDN）
- Host 配置联邦与共享，实施 SSR 数据聚合与 Cookie 透传
- 建立 props 合约与变更策略，完善降级与监控
- 验证首屏渲染一致性与 Hydration 错误，压测远程加载影响

## 最小落地建议

- React/Next 项目首选方案一，先在 Node 运行时落地一个远程组件的 SSR 组合
- 远程应用产出 `remoteEntry.js` 的 server 与 client 版本，并在 CDN 版本化
- 建立统一 BFF 层，所有 SSR 数据在 Host 聚合后以 props 传给远程组件

## App Router 最小示例

### Host 配置

```js
const { ModuleFederationPlugin } = require('webpack').container

module.exports = {
  webpack: (config, { isServer }) => {
    config.plugins.push(
      new ModuleFederationPlugin({
        name: 'host',
        remotes: {
          remote: isServer
            ? 'remote@https://cdn.example.com/server/remoteEntry.js'
            : 'remote@https://cdn.example.com/client/remoteEntry.js'
        },
        shared: {
          react: { singleton: true, requiredVersion: false },
          'react-dom': { singleton: true, requiredVersion: false }
        }
      })
    )
    return config
  }
}
```

### 布局与页面

```tsx
export default function RootLayout({ children }) {
  return (
    <html lang="zh-CN">
      <body>{children}</body>
    </html>
  )
}
```

```tsx
import { headers } from 'next/headers'
import RemoteBoundary from '../components/RemoteBoundary'

export const runtime = 'nodejs'

export default async function Page() {
  const cookie = headers().get('cookie') ?? ''
  const hostData = await fetch('https://api.example.com/host', {
    headers: { cookie },
    cache: 'no-store'
  }).then(r => r.json())
  return <RemoteBoundary hostData={hostData} />
}
```

### 客户端远程边界

```tsx
'use client'

import dynamic from 'next/dynamic'

const RemoteWidget = dynamic(() => import('remote/Widget'), { ssr: false })

export default function RemoteBoundary(props) {
  return <RemoteWidget {...props} />
}
```

### Remote 应用暴露

```tsx
'use client'

export default function Widget({ hostData }) {
  return <div>{JSON.stringify(hostData)}</div>
}
```

```js
const { ModuleFederationPlugin } = require('webpack').container

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'remote',
      filename: 'remoteEntry.js',
      exposes: {
        './Widget': './src/Widget.tsx'
      },
      shared: {
        react: { singleton: true, requiredVersion: false },
        'react-dom': { singleton: true, requiredVersion: false }
      }
    })
  ]
}
```

### 说明

- App Router 中页面默认为服务端组件，示例通过服务端取数并将数据传入客户端远程组件进行挂载
- 若需跨应用 SSR 片段，请为远程产物提供 server/client 双入口并在 Node 运行时联邦加载