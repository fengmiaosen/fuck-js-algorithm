
# 前后端鉴权方案详解

> 本文基于掘金文章《[一文教你搞定前后端所有鉴权方案，让你不再迷惘](https://juejin.cn/post/7129298214959710244)》整理而成

## 概述

前端鉴权是Web应用安全的重要组成部分，主要解决"用户是谁"和"用户能做什么"的问题。随着业务复杂度的增加，鉴权方案也在不断演进。 <mcreference link="https://juejin.cn/post/7129298214959710244" index="0">0</mcreference>

**为什么需要鉴权？**
- 保护用户隐私和数据安全
- 防止未授权访问
- 实现个性化服务
- 满足合规要求

**鉴权的发展历程：**
1. **早期阶段**：HTTP基本认证、简单的用户名密码验证
2. **Web 1.0时代**：Cookie + Session 成为主流
3. **Web 2.0时代**：Token机制兴起，支持前后端分离
4. **现代Web**：JWT、OAuth 2.0、SSO等标准化方案普及
5. **未来趋势**：零信任架构、生物识别、区块链身份验证

## 认证、授权、鉴权和权限控制

在介绍鉴权方法之前，我们需要了解几个核心概念： <mcreference link="https://juejin.cn/post/7129298214959710244" index="0">0</mcreference>

### 认证 (Identification)
认证是指根据声明者所特有的识别信息，确认声明者的身份。简单来说就是：你需要用身份证证明你自己是你自己。

**常见认证技术：**
- 身份证
- 用户名和密码
- 手机验证：短信、二维码扫描、手势密码
- 电子邮箱验证
- 生物学特征：指纹、语音、眼睛虹膜
- 大数据识别

### 授权 (Authorization)
授权是指资源所有者委派执行者，赋予执行者指定范围的资源操作权限。

**现实生活例子：** 银行卡、门禁卡、钥匙
**互联网领域例子：** Session机制、Cookie机制、Token令牌

### 鉴权 (Authentication)
鉴权是对声明者所声明的身份权利进行鉴别确认的过程。它是授权和权限控制之间的桥梁。

### 权限控制 (Access Control)
将可执行的操作定义为权限列表，然后判断操作是否允许/禁止。

**四个环节的关系：** 认证 → 授权 → 鉴权 → 权限控制（前后依次发生的上下游关系）

## 主要鉴权方案

### 0. HTTP 基本鉴权

HTTP 基本认证方案（Basic Access Authentication）是允许客户端通过用户名和密码实现身份验证的简单方案。 <mcreference link="https://juejin.cn/post/7129298214959710244" index="0">0</mcreference>

> **注意：** 由于安全性较低，几乎所有线上网站都不会使用该方案，仅作了解。

**认证流程：**

![HTTP基本鉴权流程图](./images/http-basic-auth-flow.svg)

**详细步骤：**
1. **客户端请求**：向服务器请求受限资源
   ```http
   GET /list/ HTTP/1.1
   Host: www.baidu.com
   ```

2. **服务器响应**：返回401状态码，要求身份验证
   ```http
   HTTP/1.1 401 Unauthorized
   WWW-Authenticate: Basic realm="baidu.com"
   ```

3. **用户输入**：用户提供用户名和密码

4. **重新请求**：客户端携带Base64编码的认证信息
   ```http
   GET /list/ HTTP/1.1
   Host: www.baidu.com
   Authorization: Basic aHR0cHdhdGNoOmY=
   ```

5. **成功响应**：服务器验证通过，返回资源
   ```http
   HTTP/1.1 200 OK
   Content-Type: application/json
   ```

**编码格式：** `username:password` 经过Base64编码

**缺点：**
- 密码以明文形式传输（仅Base64编码）
- 每次请求都需要发送用户名密码
- 无法主动注销
- 不支持复杂的权限控制

### 1. Cookie 方案

**核心原理：** <mcreference link="https://juejin.cn/post/7129298214959710244" index="0">0</mcreference>
- 服务端在响应头中设置 Set-Cookie
- 浏览器自动在后续请求中携带 Cookie
- 服务端通过 Cookie 识别用户身份

**认证流程：**

![Cookie/Session鉴权流程图](./images/cookie-session-flow.svg)

**Cookie 属性详解：**
- **Name/Value**：Cookie的名称和值
- **Domain**：指定Cookie的域名范围
- **Path**：指定Cookie的路径范围
- **Expires/Max-Age**：设置过期时间
- **Secure**：仅在HTTPS连接中传输
- **HttpOnly**：防止JavaScript访问，预防XSS攻击
- **SameSite**：控制跨站请求时的Cookie发送策略
  - `Strict`：完全禁止跨站发送
  - `Lax`：部分跨站场景允许发送
  - `None`：允许跨站发送（需配合Secure使用）

**实现示例：**
```javascript
// 服务端设置Cookie
res.cookie('sessionId', 'abc123', {
  httpOnly: true,
  secure: true,
  maxAge: 3600000
});

// 客户端读取Cookie
function getCookie(name) {
  const value = `; ${document.cookie}`;
  const parts = value.split(`; ${name}=`);
  return parts.length === 2 ? parts.pop().split(';').shift() : null;
}
```
```

**优点：**
- 浏览器原生支持，使用简单
- 自动携带，无需手动处理
- 支持过期时间控制
- 可设置安全属性

**缺点：**
- 受同源策略限制
- 容易受到 CSRF 攻击
- 移动端支持有限
- 存储容量限制（4KB）
- 每次请求都会携带，增加网络开销

### 2. Session 方案

**核心原理：** <mcreference link="https://juejin.cn/post/7129298214959710244" index="0">0</mcreference>
- 服务端创建 Session，生成 Session ID
- Session ID 通过 Cookie 发送给客户端
- 服务端通过 Session ID 查找对应的用户信息

**Session 生命周期：**
1. **创建**：用户首次访问或登录时创建
2. **使用**：后续请求通过Session ID识别用户
3. **更新**：延长过期时间或更新Session数据
4. **销毁**：用户登出、超时或服务器重启

**存储方式对比：**

| 存储方式 | 优点 | 缺点 | 适用场景 |
|----------|------|------|----------|
| 内存存储 | 速度快，实现简单 | 重启丢失，不支持集群 | 单机开发环境 |
| 数据库存储 | 持久化，支持集群 | 性能较慢，增加DB压力 | 小型应用 |
| Redis缓存 | 高性能，支持集群，持久化可选 | 需要额外部署 | 生产环境推荐 |
| 文件存储 | 简单，持久化 | 并发性能差，不支持集群 | 特殊场景 |

**实现示例：**
```javascript
// Session配置
app.use(session({
  store: new RedisStore({ client: redisClient }),
  secret: 'your-secret-key',
  cookie: { httpOnly: true, maxAge: 24 * 60 * 60 * 1000 }
}));

// 登录接口
app.post('/login', (req, res) => {
  if (isValidUser(username, password)) {
    req.session.userId = user.id;
    res.json({ success: true });
  }
});
```
```

**关键问题及解决方案：**

**1. 过期和销毁**
- 设置合理的过期时间（通常15-30分钟）
- 实现滑动过期（每次访问重置过期时间）
- 提供主动登出功能

**2. 分布式Session共享**
- **Session复制**：各服务器间同步Session数据
- **Session粘滞**：负载均衡器将用户请求固定到特定服务器
- **集中式存储**：使用Redis、数据库等外部存储

**3. 安全性考虑**
- Session ID要足够随机，防止被猜测
- 定期更换Session ID，防止会话固定攻击
- 设置HttpOnly和Secure属性
- 实现CSRF防护

**优点：**
- 服务端完全控制，安全性高
- 可存储复杂的用户状态
- 成熟的技术方案

**缺点：**
- 服务端需要维护状态，影响扩展性
- 分布式部署复杂
- 内存消耗随用户增长
- 不适合移动端应用

### 3. Token 方案

**核心原理：** <mcreference link="https://juejin.cn/post/7129298214959710244" index="0">0</mcreference>
- 用户登录后，服务端生成 Token
- 客户端存储 Token，每次请求携带
- 服务端验证 Token 的有效性

**认证流程：**

![Token鉴权流程图](./images/token-flow.svg)

**Token 类型：**

**1. 随机字符串Token**
```javascript
const token = crypto.randomBytes(32).toString('hex');
redis.setex(`token:${token}`, 3600, JSON.stringify({ userId: user.id }));
```

**2. 结构化Token**
```javascript
const token = { userId: user.id, exp: Date.now() + 3600000 };
const tokenString = Buffer.from(JSON.stringify(token)).toString('base64');
```

**存储方式对比：**

| 存储方式 | 安全性 | 持久性 | 跨标签页 | 适用场景 |
|----------|--------|--------|----------|----------|
| localStorage | 中等 | 持久 | 共享 | 长期登录 |
| sessionStorage | 中等 | 会话 | 不共享 | 单页面应用 |
| Cookie | 高（HttpOnly） | 可配置 | 共享 | 传统Web应用 |
| 内存变量 | 高 | 临时 | 不共享 | 高安全要求 |
| IndexedDB | 中等 | 持久 | 共享 | 大量数据存储 |

**Token 携带方式：**

**1. Authorization Header（推荐）**
```javascript
// 客户端发送
fetch('/api/user', {
  headers: { 'Authorization': 'Bearer ' + token }
});

// 服务端解析
const token = req.headers.authorization?.split(' ')[1];
```

**Token 验证中间件示例：**
```javascript
function authenticateToken(req, res, next) {
  const token = req.headers.authorization?.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({ error: 'Access token required' });
  }
  
  redis.get(`token:${token}`, (err, userData) => {
    if (err || !userData) {
      return res.status(403).json({ error: 'Invalid token' });
    }
    req.user = JSON.parse(userData);
    next();
  });
}
```
```

**Token 刷新机制：**
```javascript
// 双Token机制
const accessToken = generateToken(user, '15m');
const refreshToken = generateToken(user, '7d');

// 刷新接口
app.post('/refresh', (req, res) => {
  if (isValidRefreshToken(req.body.refreshToken)) {
    res.json({ accessToken: generateToken(user, '15m') });
  } else {
    res.status(401).json({ error: 'Invalid refresh token' });
  }
});
```
```

**优点：**
- 无状态，服务端不需要存储
- 支持跨域
- 移动端友好
- 可以携带用户信息
- 支持分布式系统

**缺点：**
- 需要手动处理 Token 携带
- Token 泄露风险
- 无法主动失效（除非维护黑名单）
- 客户端需要处理Token过期
- 存储在localStorage有XSS风险

### 4. JWT (JSON Web Token)

**核心原理：** <mcreference link="https://juejin.cn/post/7129298214959710244" index="0">0</mcreference>
- 自包含的 Token，包含用户信息
- 由 Header、Payload、Signature 三部分组成
- 通过签名防止篡改

**认证流程：**

![JWT鉴权流程图](./images/jwt-flow.svg)

**JWT 结构详解：**

**1. Header（头部）**
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```
- `alg`：签名算法（如HS256、RS256）
- `typ`：Token类型，固定为JWT

**2. Payload（载荷）**
```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022,
  "exp": 1516242622,
  "aud": "myapp",
  "iss": "myserver"
}
```

**标准声明（Registered Claims）：**
- `iss`：签发者
- `sub`：主题（通常是用户ID）
- `aud`：受众
- `exp`：过期时间
- `nbf`：生效时间
- `iat`：签发时间
- `jti`：JWT ID

**3. Signature（签名）**
```javascript
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret
)
```

**完整示例：**
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

**JWT 实现示例：**

```javascript
const jwt = require('jsonwebtoken');
const secret = 'your-256-bit-secret';

// 生成JWT
function generateJWT(user) {
  return jwt.sign(
    { sub: user.id, username: user.username },
    secret,
    { expiresIn: '1h' }
  );
}

// 验证中间件
function authenticateJWT(req, res, next) {
  const token = req.headers.authorization?.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({ error: 'Access token required' });
  }
  
  try {
    req.user = jwt.verify(token, secret);
    next();
  } catch (error) {
    res.status(403).json({ error: 'Invalid token' });
  }
}
```

**前端使用示例：**
```javascript
// 存储JWT
localStorage.setItem('accessToken', jwt);

// 自动添加到请求头
axios.interceptors.request.use(config => {
  const token = localStorage.getItem('accessToken');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});
```

**Refresh Token 机制：**
```javascript
// 双Token策略
function generateTokens(user) {
  const accessToken = jwt.sign(
    { sub: user.id, username: user.username },
    secret,
    { expiresIn: '15m' }
  );
  
  const refreshToken = jwt.sign(
    { sub: user.id, type: 'refresh' },
    refreshSecret,
    { expiresIn: '7d' }
  );
  
  return { accessToken, refreshToken };
}
```

**安全最佳实践：**

**1. 算法选择**
- 对称算法：HS256（适合单体应用）
- 非对称算法：RS256（适合微服务）

**2. 密钥管理**
```javascript
// 使用环境变量
const secret = process.env.JWT_SECRET;
```

**3. 载荷安全**
- 不要在载荷中存储敏感信息
- 控制载荷大小，避免Token过大
- 设置合理的过期时间

**优点：**
- 无需服务端存储，完全无状态
- 可携带用户信息，减少数据库查询
- 支持跨服务验证
- 标准化，生态丰富
- 支持分布式系统

**缺点：**
- 一旦签发，无法撤销（除非设置黑名单）
- Token体积较大
- 密钥泄露影响范围大
- 无法实时更新用户权限

### 5. 单点登录 (SSO)

**应用场景：** <mcreference link="https://juejin.cn/post/7129298214959710244" index="0">0</mcreference>
- 多个业务系统分散在不同域名下
- 需要"一次登录，全线通用"的能力
- 如滴滴的 didichuxing.com、xiaojukeji.com、didiglobal.com
- 企业内部多个系统的统一认证

**核心原理：** <mcreference link="https://juejin.cn/post/7129298214959710244" index="0">0</mcreference>
- 独立的 SSO 认证服务
- SSO 系统记录登录状态，下发 ticket
- 各业务系统配合存储和认证 ticket

**SSO 架构模式：**

**1. 同域SSO**
- 所有系统在同一主域名下
- 通过共享Cookie实现
- 实现简单，但扩展性有限

**2. 跨域SSO**
- 系统分布在不同域名
- 需要独立的认证中心
- 通过重定向和票据验证

**实现流程：**

![SSO流程图](./images/sso-flow-diagram.svg)

**详细步骤：**
1. **初次访问**：用户访问业务系统 A，没有登录凭证
2. **重定向认证**：A 系统跳转到 SSO 登录页面
3. **用户认证**：用户在 SSO 完成登录验证
4. **颁发票据**：SSO 生成 ticket，跳转回 A 系统
5. **票据验证**：A 系统验证 ticket，建立登录状态
6. **后续访问**：用户访问业务系统 B 时，B 系统检查 SSO 登录状态
7. **自动授权**：SSO 确认用户已登录，直接授权访问

**技术实现方案：**

**1. CAS (Central Authentication Service)**
```javascript
// CAS客户端实现示例
class CASClient {
  constructor(casServerUrl, serviceUrl) {
    this.casServerUrl = casServerUrl;
    this.serviceUrl = serviceUrl;
  }
  
  // 生成登录URL
  getLoginUrl() {
    return `${this.casServerUrl}/login?service=${encodeURIComponent(this.serviceUrl)}`;
  }
  
  // 验证票据
  async validateTicket(ticket) {
    const validateUrl = `${this.casServerUrl}/validate?ticket=${ticket}&service=${encodeURIComponent(this.serviceUrl)}`;
    const response = await fetch(validateUrl);
    const result = await response.text();
    
    if (result.startsWith('yes')) {
      const username = result.split('\n')[1];
      return { valid: true, username };
    }
    return { valid: false };
  }
}

// Express中间件
function casAuth(req, res, next) {
  const ticket = req.query.ticket;
  
  if (ticket) {
    // 验证票据
    casClient.validateTicket(ticket)
      .then(result => {
        if (result.valid) {
          req.session.user = result.username;
          res.redirect(req.originalUrl.split('?')[0]);
        } else {
          res.redirect(casClient.getLoginUrl());
        }
      });
  } else if (!req.session.user) {
    // 重定向到CAS登录
    res.redirect(casClient.getLoginUrl());
  } else {
    next();
  }
}
```

**2. SAML (Security Assertion Markup Language)**
```javascript
// SAML配置示例
const saml = require('passport-saml');

const samlStrategy = new saml.Strategy({
  entryPoint: 'https://sso.example.com/saml/sso',
  issuer: 'myapp',
  callbackUrl: 'https://myapp.com/saml/callback',
  cert: fs.readFileSync('cert.pem', 'utf8')
}, (profile, done) => {
  // 处理用户信息
  return done(null, {
    id: profile.nameID,
    email: profile.email,
    name: profile.displayName
  });
});
```

**3. 自定义SSO实现**
```javascript
// SSO服务端
class SSOServer {
  constructor() {
    this.sessions = new Map();
    this.tickets = new Map();
  }
  
  // 用户登录
  login(username, password, serviceUrl) {
    if (this.validateUser(username, password)) {
      const sessionId = this.generateSessionId();
      const ticket = this.generateTicket();
      
      this.sessions.set(sessionId, { username, loginTime: Date.now() });
      this.tickets.set(ticket, { username, serviceUrl, used: false });
      
      return { sessionId, ticket };
    }
    throw new Error('Invalid credentials');
  }
  
  // 验证票据
  validateTicket(ticket, serviceUrl) {
    const ticketData = this.tickets.get(ticket);
    
    if (ticketData && !ticketData.used && ticketData.serviceUrl === serviceUrl) {
      ticketData.used = true; // 票据只能使用一次
      return { valid: true, username: ticketData.username };
    }
    
    return { valid: false };
  }
  
  // 检查登录状态
  checkSession(sessionId) {
    return this.sessions.has(sessionId);
  }
}

// 业务系统客户端
class SSOClient {
  constructor(ssoServerUrl, appId) {
    this.ssoServerUrl = ssoServerUrl;
    this.appId = appId;
  }
  
  // 检查登录状态
  async checkLogin(req, res, next) {
    const ticket = req.query.ticket;
    
    if (ticket) {
      // 验证票据
      const result = await this.validateTicket(ticket);
      if (result.valid) {
        req.session.user = result.username;
        return res.redirect(req.path);
      }
    }
    
    if (!req.session.user) {
      // 重定向到SSO登录
      const loginUrl = `${this.ssoServerUrl}/login?service=${encodeURIComponent(req.originalUrl)}`;
      return res.redirect(loginUrl);
    }
    
    next();
  }
}
```

**跨域处理方案：** <mcreference link="https://juejin.cn/post/7129298214959710244" index="0">0</mcreference>

**1. iframe + postMessage**
```javascript
// 在各业务系统中嵌入SSO iframe
function checkSSOStatus() {
  const iframe = document.createElement('iframe');
  iframe.src = 'https://sso.example.com/check';
  iframe.style.display = 'none';
  
  iframe.onload = () => {
    iframe.contentWindow.postMessage('checkLogin', 'https://sso.example.com');
  };
  
  window.addEventListener('message', (event) => {
    if (event.origin === 'https://sso.example.com') {
      if (event.data.loggedIn) {
        // 用户已登录
        handleLoggedIn(event.data.userInfo);
      } else {
        // 用户未登录
        redirectToLogin();
      }
    }
  });
  
  document.body.appendChild(iframe);
}
```

**2. JSONP轮询**
```javascript
// 定期检查SSO登录状态
function pollSSOStatus() {
  const script = document.createElement('script');
  script.src = `https://sso.example.com/status?callback=handleSSOStatus&t=${Date.now()}`;
  document.head.appendChild(script);
}

function handleSSOStatus(data) {
  if (data.loggedIn) {
    // 处理登录状态
  } else {
    // 处理未登录状态
  }
}

setInterval(pollSSOStatus, 30000); // 30秒检查一次
```

**安全考虑：**
- **票据安全**：票据应该一次性使用，设置短期过期时间
- **传输安全**：使用HTTPS传输，防止票据被截获
- **域名验证**：验证回调域名，防止票据被恶意网站获取
- **会话管理**：实现会话超时和主动登出

**优点：**
- 用户体验好，一次登录全站通用
- 统一的用户管理和权限控制
- 减少密码泄露风险
- 便于审计和监控

**缺点：**
- 实现复杂度高
- SSO服务成为单点故障
- 跨域实现有技术挑战
- 需要各系统配合改造

### 6. OAuth 2.0

**应用场景：** <mcreference link="https://juejin.cn/post/7129298214959710244" index="0">0</mcreference>
- 第三方应用授权访问用户资源
- 无需暴露用户密码给第三方
- 支持细粒度的权限控制

**核心原理：**
- 通过授权服务器颁发访问令牌
- 客户端使用令牌访问受保护资源
- 支持多种授权模式

**授权流程：**

![OAuth 2.0授权流程图](./images/oauth-flow.svg)

**主要角色：**
- **资源所有者 (Resource Owner)**：用户
- **客户端 (Client)**：第三方应用
- **授权服务器 (Authorization Server)**：颁发令牌
- **资源服务器 (Resource Server)**：提供API服务

**授权模式：**
- **授权码模式**：最安全，适用于服务端应用
- **简化模式**：适用于纯前端应用
- **密码模式**：适用于可信任的客户端
- **客户端凭证模式**：适用于服务间调用

**优点：**
- 标准化协议，广泛支持
- 安全性高，职责分离
- 支持细粒度权限控制
- 可撤销授权

**缺点：**
- 实现复杂度较高
- 需要多次重定向
- 对网络要求较高

### 7. 扫码登录

> 参考：[掘金文章 - 前端鉴权方案详解](https://juejin.cn/post/7129298214959710244)

扫码登录通常见于移动端 APP 中，很多 PC 端的网站都提供了扫码登录的功能，无需在网页上输入任何账号和密码，只需要让移动端 APP（如微信、淘宝、QQ等）中已登录用户主动扫描二维码，再确认登录，以使 PC 端的同款应用得以快速登录。

#### 7.1 应用场景

- **跨设备登录**：PC端网站通过移动端APP扫码登录
- **安全便捷**：避免在不信任设备上输入密码
- **企业应用**：内部系统通过企业微信等扫码登录
- **支付场景**：支付宝、微信支付等扫码确认

#### 7.2 认证流程

![扫码登录流程图](./images/qr-code-login-flow.svg)

#### 7.3 详细步骤

1. **生成二维码**：PC端向服务器请求生成唯一的二维码，包含临时token
2. **展示二维码**：PC端展示二维码，等待用户扫描
3. **扫码识别**：移动端APP扫描二维码，获取临时token
4. **用户确认**：移动端显示登录确认页面，用户点击确认
5. **服务器验证**：服务器验证移动端用户身份和临时token
6. **状态同步**：服务器通知PC端登录成功，返回用户信息
7. **登录完成**：PC端获取用户信息，完成登录流程

#### 7.4 技术实现

**1. 二维码生成**
```javascript
// 服务端生成二维码数据
const generateQRCode = () => {
  const qrToken = generateUniqueToken();
  const qrData = {
    token: qrToken,
    expiry: Date.now() + 5 * 60 * 1000
  };
  
  redis.setex(`qr:${qrToken}`, 300, JSON.stringify({ status: 'pending' }));
  return qrData;
};

// 前端生成二维码
const displayQRCode = async (qrData) => {
  const qrCodeDataURL = await QRCode.toDataURL(JSON.stringify(qrData));
  document.getElementById('qrcode').src = qrCodeDataURL;
};
```

**2. 轮询状态检查**
```javascript
// PC端轮询检查登录状态
const pollLoginStatus = (qrToken) => {
  const poll = setInterval(async () => {
    const response = await fetch(`/api/qr-status/${qrToken}`);
    const data = await response.json();
    
    switch (data.status) {
      case 'confirmed':
        clearInterval(poll);
        handleLoginSuccess(data.userInfo, data.token);
        break;
      case 'expired':
        clearInterval(poll);
        showQRExpired();
        break;
    }
  }, 2000);
};
```

**3. 移动端扫码处理**
```javascript
// 移动端扫码后的处理
const handleQRScan = async (qrData) => {
  const { token, expiry } = JSON.parse(qrData);
  
  if (Date.now() > expiry) {
    showError('二维码已过期');
    return;
  }
  
  // 显示确认页面
  showConfirmationPage(token);
};

// 用户确认登录
const confirmLogin = async (qrToken) => {
  const response = await fetch('/api/qr-confirm', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${userToken}`
    },
    body: JSON.stringify({ qrToken })
  });
};
```

**4. WebSocket实时通信（优化方案）**
```javascript
// 替代轮询的WebSocket方案
const connectWebSocket = (qrToken) => {
  const ws = new WebSocket(`ws://localhost:3000/qr-login/${qrToken}`);
  
  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    
    if (data.type === 'confirmed') {
      handleLoginSuccess(data.userInfo, data.token);
      ws.close();
    }
  };
};
```

#### 7.5 安全考虑

**1. 时效性控制**
- 二维码设置合理的过期时间（通常2-5分钟）
- 一次性使用，扫码后立即失效
- 定期清理过期的二维码数据

**2. 防重放攻击**
```javascript
// 添加随机数和时间戳
const generateSecureQRData = () => {
  const token = generateUniqueToken();
  const nonce = crypto.randomBytes(16).toString('hex');
  return {
    token,
    nonce,
    timestamp: Date.now(),
    signature: generateSignature(token, nonce)
  };
};
```

**3. 权限验证**
- 移动端必须是已登录状态
- 验证移动端用户权限
- 记录登录日志和设备信息

#### 7.6 优缺点分析

**优点：**
- 用户体验好，无需输入密码
- 安全性高，避免密码泄露
- 支持跨设备登录
- 可以传递额外的上下文信息

**缺点：**
- 需要移动端APP支持
- 实现复杂度较高
- 依赖网络连接
- 需要额外的服务器资源

### 8. 一键登录

> 参考：[掘金文章 - 前端鉴权方案详解](https://juejin.cn/post/7129298214959710244)

一键登录是基于运营商网关认证的登录方式，通过运营商的网关来获取用户的手机号码，从而实现快速登录，无需用户手动输入手机号和验证码。

#### 8.1 应用场景

- **移动端APP**：新用户注册和老用户登录
- **电商平台**：快速注册购买流程
- **金融应用**：实名认证和快速开户
- **社交应用**：降低注册门槛

#### 8.2 认证流程

1. **发起认证**：APP调用运营商SDK发起一键登录
2. **网关验证**：运营商验证当前网络环境和SIM卡信息
3. **获取凭证**：运营商返回临时凭证（token）
4. **服务器验证**：APP将凭证发送到业务服务器
5. **运营商校验**：业务服务器向运营商验证凭证有效性
6. **返回手机号**：运营商返回脱敏的手机号信息
7. **完成登录**：业务服务器完成用户登录或注册

#### 8.3 技术实现

**1. 移动端集成**
```javascript
// React Native示例
import { OneKeyLogin } from '@react-native-community/onekey-login';

const handleOneKeyLogin = async () => {
  try {
    // 检查网络环境
    const isSupported = await OneKeyLogin.checkEnvironment();
    if (!isSupported) {
      // 降级到短信验证码登录
      showSMSLogin();
      return;
    }
    
    // 预取号（可选，提升用户体验）
    await OneKeyLogin.preGetToken();
    
    // 显示授权页面
    const result = await OneKeyLogin.getToken({
      timeout: 10000,
      authPageConfig: {
        title: '一键登录',
        logoImage: 'logo.png',
        sloganText: '欢迎使用一键登录'
      }
    });
    
    if (result.success) {
      // 发送token到服务器验证
      await verifyTokenWithServer(result.token);
    }
  } catch (error) {
    console.error('一键登录失败:', error);
    // 降级处理
    showAlternativeLogin();
  }
};
```

**2. 服务端验证**
```javascript
// Node.js服务端验证
const verifyOneKeyToken = async (token, operator) => {
  try {
    let verifyUrl;
    let appKey;
    let appSecret;
    
    // 根据运营商选择对应的验证接口
    switch (operator) {
      case 'CMCC': // 中国移动
        verifyUrl = 'https://www.cmpassport.com/unisdk/rsapi/tokenValidate';
        appKey = process.env.CMCC_APP_KEY;
        appSecret = process.env.CMCC_APP_SECRET;
        break;
      case 'CUCC': // 中国联通
        verifyUrl = 'https://opencloud.wostore.cn/authz/resource/html';
        appKey = process.env.CUCC_APP_KEY;
        appSecret = process.env.CUCC_APP_SECRET;
        break;
      case 'CTCC': // 中国电信
        verifyUrl = 'https://id.189.cn/html/oauth.html';
        appKey = process.env.CTCC_APP_KEY;
        appSecret = process.env.CTCC_APP_SECRET;
        break;
      default:
        throw new Error('不支持的运营商');
    }
    
    const response = await fetch(verifyUrl, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${appKey}`
      },
      body: JSON.stringify({ token })
    });
    
    const result = await response.json();
    
    if (result.code === '0000') {
      return {
        success: true,
        mobile: result.mobile,
        operator: operator
      };
    } else {
      throw new Error(result.message || '验证失败');
    }
  } catch (error) {
    return {
      success: false,
      error: error.message
    };
  }
};
```

**3. 完整登录流程**
```javascript
// 完整的一键登录处理流程
const handleOneKeyLoginFlow = async (req, res) => {
  const { token, operator } = req.body;
  
  const verifyResult = await verifyOneKeyToken(token, operator);
  
  if (!verifyResult.success) {
    return res.status(400).json({
      error: '一键登录验证失败'
    });
  }
  
  const mobile = verifyResult.mobile;
  let user = await User.findOne({ mobile });
  
  if (!user) {
    user = await User.create({
      mobile,
      registerType: 'onekey'
    });
  }
  
  const jwtToken = jwt.sign(
    { userId: user._id, mobile: user.mobile },
    process.env.JWT_SECRET,
    { expiresIn: '7d' }
  );
  
  res.json({
    success: true,
    token: jwtToken,
    user: {
      id: user._id,
      mobile: user.mobile
    }
  });
};
```

#### 8.4 降级策略

```javascript
// 智能降级处理
const smartLoginFallback = async () => {
  try {
    const oneKeyResult = await attemptOneKeyLogin();
    if (oneKeyResult.success) {
      return oneKeyResult;
    }
    
    return await showSMSLogin();
  } catch (error) {
    return await showPasswordLogin();
  }
};

// 网络环境检测
const checkNetworkEnvironment = async () => {
  const networkInfo = await getNetworkInfo();
  const isMobileNetwork = networkInfo.type === 'cellular';
  
  if (isMobileNetwork) {
    const operator = await getOperatorInfo();
    const operatorSupported = ['CMCC', 'CUCC', 'CTCC'].includes(operator);
    const sdkAvailable = await OneKeyLogin.isAvailable();
    
    return { isMobileNetwork, operatorSupported, sdkAvailable };
  }
  
  return { isMobileNetwork: false };
};
```

#### 8.5 安全考虑

**1. 防刷机制**
```javascript
// 频率限制
const rateLimiter = {
  attempts: new Map(),
  
  checkLimit(deviceId) {
    const now = Date.now();
    const attempts = this.attempts.get(deviceId) || [];
    const validAttempts = attempts.filter(time => now - time < 3600000);
    
    if (validAttempts.length >= 10) {
      throw new Error('请求过于频繁，请稍后再试');
    }
    
    validAttempts.push(now);
    this.attempts.set(deviceId, validAttempts);
  }
};
```

**2. 设备指纹**
```javascript
// 设备指纹验证
const generateDeviceFingerprint = (req) => {
  const factors = [req.get('User-Agent'), req.ip];
  return crypto.createHash('sha256').update(factors.join('|')).digest('hex');
};
```

#### 8.6 优缺点分析

**优点：**
- 用户体验极佳，真正的一键登录
- 安全性高，基于运营商网关认证
- 转化率高，降低用户流失
- 获取真实手机号，便于后续营销

**缺点：**
- 仅支持移动网络环境
- 需要集成多个运营商SDK
- 成本较高，按次数收费
- 对网络环境要求严格

### 9. 生物识别认证

> 参考：[掘金文章 - 前端鉴权方案详解](https://juejin.cn/post/7129298214959710244)

生物识别认证是利用人体固有的生理特征（如指纹、面部、虹膜等）或行为特征（如声音、签名等）来进行身份验证的技术。

#### 9.1 认证类型

**1. 指纹识别**
- Touch ID（苹果）
- 安卓指纹识别
- Windows Hello指纹

**2. 面部识别**
- Face ID（苹果）
- 安卓面部解锁
- Windows Hello面部识别

**3. 声纹识别**
- 语音密码
- 声纹验证

**4. 虹膜识别**
- 三星虹膜识别
- 专业虹膜设备

#### 9.2 Web端实现

**1. WebAuthn API**
```javascript
// 注册生物识别凭证
const registerBiometric = async (userId, userName) => {
  try {
    // 检查浏览器支持
    if (!window.PublicKeyCredential) {
      throw new Error('浏览器不支持WebAuthn');
    }
    
    // 创建凭证选项
    const createCredentialOptions = {
      publicKey: {
        challenge: new Uint8Array(32),
        rp: {
          name: "Your App Name",
          id: "yourdomain.com"
        },
        user: {
          id: new TextEncoder().encode(userId),
          name: userName,
          displayName: userName
        },
        pubKeyCredParams: [
          { alg: -7, type: "public-key" }, // ES256
          { alg: -257, type: "public-key" } // RS256
        ],
        authenticatorSelection: {
          authenticatorAttachment: "platform", // 平台认证器（如Touch ID）
          userVerification: "required"
        },
        timeout: 60000,
        attestation: "direct"
      }
    };
    
    // 创建凭证
    const credential = await navigator.credentials.create(createCredentialOptions);
    
    // 发送到服务器保存
    const response = await fetch('/api/biometric/register', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        userId,
        credentialId: Array.from(new Uint8Array(credential.rawId)),
        publicKey: Array.from(new Uint8Array(credential.response.publicKey)),
        attestationObject: Array.from(new Uint8Array(credential.response.attestationObject))
      })
    });
    
    if (response.ok) {
      console.log('生物识别注册成功');
      return true;
    }
  } catch (error) {
    console.error('生物识别注册失败:', error);
    return false;
  }
};

// 生物识别登录
const loginWithBiometric = async () => {
  try {
    const challengeResponse = await fetch('/api/biometric/challenge');
    const { challenge, allowCredentials } = await challengeResponse.json();
    
    const getCredentialOptions = {
      publicKey: {
        challenge: new Uint8Array(challenge),
        allowCredentials: allowCredentials.map(cred => ({
          id: new Uint8Array(cred.id),
          type: 'public-key'
        })),
        userVerification: 'required'
      }
    };
    
    const assertion = await navigator.credentials.get(getCredentialOptions);
    
    const verifyResponse = await fetch('/api/biometric/verify', {
      method: 'POST',
      body: JSON.stringify({
        credentialId: Array.from(new Uint8Array(assertion.rawId)),
        signature: Array.from(new Uint8Array(assertion.response.signature))
      })
    });
    
    const result = await verifyResponse.json();
    
    if (result.success) {
      localStorage.setItem('authToken', result.token);
      window.location.href = '/dashboard';
    }
  } catch (error) {
    showAlternativeLogin();
  }
};
```

**2. 移动端实现**
```javascript
// React Native生物识别
import TouchID from 'react-native-touch-id';
import FaceID from 'react-native-face-id';

const BiometricAuth = {
  // 检查生物识别支持
  async checkSupport() {
    try {
      const biometryType = await TouchID.isSupported();
      return {
        supported: true,
        type: biometryType // 'TouchID', 'FaceID', 'Fingerprint'
      };
    } catch (error) {
      return {
        supported: false,
        error: error.message
      };
    }
  },
  
  // 生物识别认证
  async authenticate(reason = '请验证您的身份') {
    try {
      await TouchID.authenticate(reason);
      return { success: true };
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  },
  
  // 注册生物识别
  async register(userId) {
    const authResult = await this.authenticate('注册生物识别登录');
    
    if (authResult.success) {
      const deviceId = await getDeviceId();
      
      const response = await fetch('/api/biometric/register', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${getAuthToken()}`
        },
        body: JSON.stringify({ userId, deviceId })
      });
      
      return response.ok;
    }
    
    return false;
  }
};
```

#### 9.3 服务端处理

```javascript
// 生物识别服务端验证
const biometricService = {
  // 注册生物识别设备
  async registerDevice(userId, deviceInfo) {
    try {
      const device = await BiometricDevice.create({
        userId,
        deviceId: deviceInfo.deviceId,
        registeredAt: new Date(),
        isActive: true
      });
      
      return { success: true, deviceId: device._id };
    } catch (error) {
      return { success: false, error: error.message };
    }
  },
  
  // 验证生物识别
  async verifyBiometric(credentialData) {
    try {
      const device = await BiometricDevice.findOne({
        deviceId: credentialData.deviceId,
        isActive: true
      });
      
      if (!device) {
        throw new Error('设备未注册或已禁用');
      }
      
      const isValid = await this.verifySignature(
        device.publicKey,
        credentialData.signature
      );
      
      if (isValid) {
        const token = jwt.sign(
          { userId: device.userId, loginType: 'biometric' },
          process.env.JWT_SECRET,
          { expiresIn: '24h' }
        );
        
        return { success: true, token };
      }
      
      throw new Error('生物识别验证失败');
    } catch (error) {
      return { success: false, error: error.message };
    }
  },
  
  // 验证数字签名
  async verifySignature(publicKey, signature) {
    // 使用公钥验证签名的实现
    return true; // 简化示例
  }
};
```

#### 9.4 安全考虑

**1. 防欺骗措施**
```javascript
// 活体检测
const livenessDetection = {
  generateChallenge() {
    const actions = ['眨眼', '张嘴', '点头', '摇头'];
    return actions[Math.floor(Math.random() * actions.length)];
  },
  
  async multiFactorAuth(userId) {
    const steps = [
      () => this.biometricAuth(userId),
      () => this.deviceVerification(userId)
    ];
    
    for (const step of steps) {
      const result = await step();
      if (!result.success) {
        return result;
      }
    }
    
    return { success: true };
  }
};
```

**2. 隐私保护**
```javascript
// 生物特征数据保护
const biometricPrivacy = {
  // 本地存储加密
  encryptBiometricData(data, userKey) {
    return crypto.encrypt(data, userKey);
  },
  
  // 模板哈希化
  hashTemplate(template) {
    return crypto.createHash('sha256')
      .update(template)
      .digest('hex');
  },
  
  // 数据最小化
  minimizeData(biometricData) {
    // 只保留必要的特征点
    return biometricData.essentialFeatures;
  }
};
```

#### 9.5 优缺点分析

**优点：**
- 安全性极高，难以伪造
- 用户体验好，无需记忆密码
- 无法丢失或遗忘
- 支持离线验证

**缺点：**
- 设备依赖性强
- 隐私担忧
- 成本较高
- 可能存在误识别

### 10. 多因素认证（MFA）

> 参考：[掘金文章 - 前端鉴权方案详解](https://juejin.cn/post/7129298214959710244)

多因素认证（Multi-Factor Authentication，MFA）是一种安全机制，要求用户提供两个或更多验证因素来证明身份，大大提高了账户安全性。

#### 10.1 认证因素分类

**1. 知识因素（Something you know）**
- 密码
- PIN码
- 安全问题答案

**2. 持有因素（Something you have）**
- 手机短信
- 硬件令牌
- 移动应用（如Google Authenticator）

**3. 生物因素（Something you are）**
- 指纹
- 面部识别
- 声纹识别

#### 10.2 常见MFA组合

**1. 密码 + 短信验证码**
```javascript
// 两步验证流程
const twoStepAuth = {
  // 第一步：密码验证
  async step1_passwordAuth(username, password) {
    const user = await User.findOne({ username });
    
    if (!user || !await bcrypt.compare(password, user.passwordHash)) {
      throw new Error('用户名或密码错误');
    }
    
    const tempToken = jwt.sign(
      { userId: user._id, step: 1 },
      process.env.JWT_SECRET,
      { expiresIn: '5m' }
    );
    
    const smsCode = generateSMSCode();
    await this.sendSMS(user.mobile, smsCode);
    await redis.setex(`sms:${user._id}`, 300, smsCode);
    
    return {
      success: true,
      tempToken,
      nextStep: 'sms_verification'
    };
  },
  
  // 第二步：短信验证
  async step2_smsVerification(tempToken, smsCode) {
    const decoded = jwt.verify(tempToken, process.env.JWT_SECRET);
    
    if (decoded.step !== 1) {
      throw new Error('无效的验证步骤');
    }
    
    const storedCode = await redis.get(`sms:${decoded.userId}`);
    
    if (!storedCode || storedCode !== smsCode) {
      throw new Error('验证码错误或已过期');
    }
    
    await redis.del(`sms:${decoded.userId}`);
    
    const finalToken = jwt.sign(
      { userId: decoded.userId, mfa: true },
      process.env.JWT_SECRET,
      { expiresIn: '7d' }
    );
    
    return {
      success: true,
      token: finalToken
    };
  }
};
```

**2. 密码 + TOTP（Time-based One-Time Password）**
```javascript
// TOTP实现
const totpAuth = {
  // 生成TOTP密钥
  generateSecret(userId) {
    const secret = speakeasy.generateSecret({
      name: `YourApp (${userId})`,
      issuer: 'YourApp',
      length: 32
    });
    
    return {
      secret: secret.base32,
      qrCode: secret.otpauth_url
    };
  },
  
  // 验证TOTP代码
  verifyTOTP(secret, token) {
    return speakeasy.totp.verify({
      secret: secret,
      encoding: 'base32',
      token: token,
      window: 2 // 允许时间偏差
    });
  },
  
  // 启用TOTP
  async enableTOTP(userId, totpCode) {
    const user = await User.findById(userId);
    
    if (!user.totpSecret) {
      throw new Error('请先生成TOTP密钥');
    }
    
    const isValid = this.verifyTOTP(user.totpSecret, totpCode);
    
    if (!isValid) {
      throw new Error('TOTP代码错误');
    }
    
    await User.updateOne(
      { _id: userId },
      { totpEnabled: true }
    );
    
    const backupCodes = this.generateBackupCodes();
    await this.saveBackupCodes(userId, backupCodes);
    
    return {
      success: true,
      backupCodes
    };
  },
  
  // 生成备用代码
  generateBackupCodes() {
    const codes = [];
    for (let i = 0; i < 10; i++) {
      codes.push(crypto.randomBytes(4).toString('hex').toUpperCase());
    }
    return codes;
  }
};
```

**3. 前端MFA组件**
```javascript
// React MFA组件
import React, { useState } from 'react';
import QRCode from 'qrcode.react';

const MFASetup = ({ userId }) => {
  const [step, setStep] = useState(1);
  const [secret, setSecret] = useState('');
  const [qrCode, setQRCode] = useState('');
  const [totpCode, setTotpCode] = useState('');
  const [backupCodes, setBackupCodes] = useState([]);
  
  // 生成TOTP密钥
  const generateTOTPSecret = async () => {
    const response = await fetch('/api/mfa/generate-secret', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${getAuthToken()}`
      },
      body: JSON.stringify({ userId })
    });
    
    const data = await response.json();
    
    if (data.success) {
      setSecret(data.secret);
      setQRCode(data.qrCode);
      setStep(2);
    }
  };
  
  // 验证并启用TOTP
  const enableTOTP = async () => {
    const response = await fetch('/api/mfa/enable-totp', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${getAuthToken()}`
      },
      body: JSON.stringify({ userId, totpCode })
    });
    
    const data = await response.json();
    
    if (data.success) {
      setBackupCodes(data.backupCodes);
      setStep(3);
    } else {
      alert(data.error);
    }
  };
  
  return (
    <div className="mfa-setup">
      {step === 1 && (
        <div>
          <h3>设置双因素认证</h3>
          <p>双因素认证可以大大提高您账户的安全性</p>
          <button onClick={generateTOTPSecret}>
            开始设置
          </button>
        </div>
      )}
      
      {step === 2 && (
        <div>
          <h3>扫描二维码</h3>
          <p>使用Google Authenticator或类似应用扫描下方二维码</p>
          <QRCode value={qrCode} size={200} />
          <div>
            <p>或手动输入密钥：</p>
            <code>{secret}</code>
          </div>
          <div>
            <input
              type="text"
              placeholder="输入6位验证码"
              value={totpCode}
              onChange={(e) => setTotpCode(e.target.value)}
              maxLength={6}
            />
            <button onClick={enableTOTP}>
              验证并启用
            </button>
          </div>
        </div>
      )}
      
      {step === 3 && (
        <div>
          <h3>设置完成</h3>
          <p>双因素认证已启用！请保存以下备用代码：</p>
          <div className="backup-codes">
            {backupCodes.map((code, index) => (
              <div key={index} className="backup-code">{code}</div>
            ))}
          </div>
          <p className="warning">
            请将备用代码保存在安全的地方，当您无法使用认证应用时可以使用这些代码登录。
          </p>
        </div>
      )}
    </div>
  );
};
```

#### 10.3 自适应MFA

```javascript
// 基于风险的自适应认证
const adaptiveMFA = {
  async assessRisk(loginAttempt) {
    let riskScore = 0;
    if (await this.isNewLocation(loginAttempt.ip, loginAttempt.userId)) riskScore += 30;
    if (await this.isNewDevice(loginAttempt.deviceFingerprint, loginAttempt.userId)) riskScore += 25;
    return { score: riskScore, level: this.getRiskLevel(riskScore) };
  },
  
  determineAuthRequirements(riskLevel, userPreferences) {
    const requirements = { password: true, factors: [] };
    if (riskLevel === 'medium' && userPreferences.totpEnabled) {
      requirements.factors.push('totp');
    } else if (riskLevel === 'high') {
      requirements.factors.push('totp', 'sms');
    }
    return requirements;
  },
  
  async performAdaptiveAuth(loginAttempt) {
    const risk = await this.assessRisk(loginAttempt);
    const userPreferences = await this.getUserMFAPreferences(loginAttempt.userId);
    const requirements = this.determineAuthRequirements(risk.level, userPreferences);
    return { success: true, riskLevel: risk.level, authRequirements: requirements };
  }
};
```

#### 10.4 MFA管理界面

```javascript
const MFAManagement = () => {
  const [mfaStatus, setMfaStatus] = useState({ totpEnabled: false, smsEnabled: false });
  
  const toggleMFAMethod = async (method, enabled) => {
    await fetch(`/api/mfa/${method}`, {
      method: enabled ? 'POST' : 'DELETE',
      headers: { 'Authorization': `Bearer ${getAuthToken()}` }
    });
    setMfaStatus(prev => ({ ...prev, [`${method}Enabled`]: enabled }));
  };
  
  return (
    <div className="mfa-management">
      <h2>双因素认证管理</h2>
      <div className="mfa-methods">
        <label>
          <input
            type="checkbox"
            checked={mfaStatus.totpEnabled}
            onChange={(e) => toggleMFAMethod('totp', e.target.checked)}
          />
          启用TOTP认证
        </label>
        <label>
          <input
            type="checkbox"
            checked={mfaStatus.smsEnabled}
            onChange={(e) => toggleMFAMethod('sms', e.target.checked)}
          />
          启用短信验证
        </label>
      </div>
    </div>
  );
};
```

#### 10.5 优缺点分析

**优点：**
- 安全性极高，多层防护
- 可根据风险自适应调整
- 支持多种认证方式
- 符合安全合规要求

**缺点：**
- 用户体验复杂
- 实现成本高
- 可能影响登录速度
- 需要用户配合设置


## 方案对比

| 方案 | 状态存储 | 跨域支持 | 安全性 | 扩展性 | 适用场景 |
|------|----------|----------|--------|--------|-----------|
| HTTP基本鉴权 | 无 | 支持 | 低 | 差 | 简单API测试 |
| Cookie | 客户端 | 受限 | 中等 | 一般 | 传统Web应用 |
| Session | 服务端 | 受限 | 较高 | 较差 | 单体应用 |
| Token | 客户端 | 支持 | 中等 | 较好 | 前后端分离 |
| JWT | 客户端 | 支持 | 较高 | 很好 | 微服务架构 |
| SSO | 独立服务 | 支持 | 高 | 很好 | 多系统集成 |
| OAuth 2.0 | 授权服务器 | 支持 | 很高 | 很好 | 第三方授权 |

## 最佳实践

### 1. 方案选择指南

**根据应用场景选择：**

| 场景 | 推荐方案 | 理由 |
|------|----------|------|
| 传统Web应用 | Cookie + Session | 成熟稳定，安全性高 |
| 前后端分离 | JWT | 无状态，支持跨域 |
| 移动端应用 | Token/JWT | 移动端友好，灵活性高 |
| 微服务架构 | JWT | 支持分布式验证 |
| 多系统集成 | SSO | 统一认证，用户体验好 |
| 第三方授权 | OAuth 2.0 | 标准化，安全性高 |
| API服务 | API Key + Token | 简单高效 |

**技术栈考虑：**
- **Node.js**：推荐JWT，生态丰富
- **Java**：Session + Redis，或Spring Security + JWT
- **Python**：Django Session，或Flask + JWT
- **.NET**：ASP.NET Identity + JWT
- **Go**：JWT + Redis

### 2. 安全防护策略

**传输安全：**
```javascript
// 强制HTTPS
app.use((req, res, next) => {
  if (req.header('x-forwarded-proto') !== 'https') {
    res.redirect(`https://${req.header('host')}${req.url}`);
  } else {
    next();
  }
});
```

**CSRF防护：**
```javascript
// 使用CSRF Token
const csrf = require('csurf');
app.use(csrf({ cookie: true }));

// 双重Cookie验证
function validateCSRFToken(req) {
  const headerToken = req.headers['x-csrf-token'];
  const cookieToken = req.cookies['csrf-token'];
  return headerToken && headerToken === cookieToken;
}
```

**XSS防护：**
```javascript
// 输入验证和转义
const xss = require('xss');

function sanitizeInput(input) {
  return xss(input);
}
```

**密码安全：**
```javascript
const bcrypt = require('bcrypt');

// 密码加密
async function hashPassword(password) {
  return await bcrypt.hash(password, 12);
}

// 密码验证
async function verifyPassword(password, hash) {
  return await bcrypt.compare(password, hash);
}
```

**会话安全：**
```javascript
// Session配置
app.use(session({
  secret: process.env.SESSION_SECRET,
  cookie: {
    secure: true,
    httpOnly: true,
    maxAge: 1800000,
    sameSite: 'strict'
  }
}));
```

### 3. 用户体验优化

**自动续期机制：**
```javascript
// JWT自动刷新
class TokenManager {
  shouldRefresh(token) {
    const decoded = jwt.decode(token);
    const now = Date.now() / 1000;
    return (decoded.exp - now) < 300; // 5分钟内过期
  }
  
  async autoRefresh(token) {
    if (this.shouldRefresh(token)) {
      const response = await fetch('/api/refresh', {
        method: 'POST',
        headers: { 'Authorization': `Bearer ${token}` }
      });
      const { accessToken } = await response.json();
      localStorage.setItem('accessToken', accessToken);
      return accessToken;
    }
    return token;
  }
}
```

**优雅的错误处理：**
```javascript
// 统一错误处理
class AuthErrorHandler {
  static handle(error, router) {
    switch (error.status) {
      case 401:
        this.clearAuthData();
        router.push('/login');
        break;
      case 403:
        router.push('/unauthorized');
        break;
    }
  }
  
  static clearAuthData() {
    localStorage.removeItem('accessToken');
    localStorage.removeItem('refreshToken');
  }
}
```

**记住登录状态：**
```javascript
// 智能登录状态管理
class LoginStateManager {
  constructor() {
    this.rememberKey = 'rememberLogin';
    this.userKey = 'userInfo';
  }
  
  saveLoginState(userInfo, remember = false) {
    const storage = remember ? localStorage : sessionStorage;
    storage.setItem(this.userKey, JSON.stringify(userInfo));
    localStorage.setItem(this.rememberKey, remember.toString());
  }
  
  getLoginState() {
    const remember = localStorage.getItem(this.rememberKey) === 'true';
    const storage = remember ? localStorage : sessionStorage;
    const userInfo = storage.getItem(this.userKey);
    return userInfo ? JSON.parse(userInfo) : null;
  }
  
  clearLoginState() {
    localStorage.removeItem(this.rememberKey);
    localStorage.removeItem(this.userKey);
    sessionStorage.removeItem(this.userKey);
  }
}
```

### 4. 监控和审计

**登录日志记录：**
```javascript
// 登录审计
class LoginAudit {
  static async logLoginAttempt(username, success, req) {
    const logData = {
      username,
      success,
      ip: req.ip,
      userAgent: req.headers['user-agent'],
      timestamp: new Date(),
      location: await this.getLocationByIP(req.ip)
    };
    
    await db.loginLogs.create(logData);
    
    // 异常检测
    if (!success) {
      await this.checkFailedAttempts(username, req.ip);
    }
  }
  
  static async checkFailedAttempts(username, ip) {
    const recentFails = await db.loginLogs.count({
      where: {
        username,
        success: false,
        timestamp: {
          [Op.gte]: new Date(Date.now() - 15 * 60 * 1000) // 15分钟内
        }
      }
    });
    
    if (recentFails >= 5) {
      // 触发账户锁定或IP封禁
      await this.lockAccount(username);
      await this.notifySecurityTeam(username, ip);
    }
  }
}
```

**性能监控：**
```javascript
// 认证性能监控
class AuthMetrics {
  static trackAuthTime(operation, startTime) {
    const duration = Date.now() - startTime;
    console.log(`Auth operation ${operation} took ${duration}ms`);
    
    // 发送到监控系统
    metrics.timing(`auth.${operation}.duration`, duration);
  }
  
  static trackAuthSuccess(method) {
    metrics.increment(`auth.${method}.success`);
  }
  
  static trackAuthFailure(method, reason) {
    metrics.increment(`auth.${method}.failure`, { reason });
  }
}
```


## 参考资料

- [前端鉴权 cookie、session、token、jwt、单点登录](https://blog.csdn.net/lixinhua_man/article/details/122553345)
- [鉴权 5 兄弟：cookie、session、token、jwt、单点登录](https://segmentfault.com/a/1190000041301160)
- [前端鉴权：cookie、session、token、jwt、单点登录](https://segmentfault.com/a/1190000040524090)
- [前端鉴权的兄弟们：cookie、session、token、jwt、单点登录](https://zhuanlan.zhihu.com/p/281414244)
- [掘金文章 - 一文教你搞定所有前端鉴权与后端鉴权方案](https://juejin.cn/post/7129298214959710244)