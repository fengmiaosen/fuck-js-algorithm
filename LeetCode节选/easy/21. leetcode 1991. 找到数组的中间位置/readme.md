# LeetCode 1991: 找到数组的中间位置

## 题目描述

给你一个整数数组 `nums`，请计算数组的**中心下标**。

数组**中心下标**是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。

### 规则说明

- 如果中心下标位于数组最左端，那么左侧数之和视为 `0`，因为在下标的左侧不存在元素
- 这一点对于中心下标位于数组最右端同样适用
- 如果数组有多个中心下标，应该返回**最靠近左边**的那一个
- 如果数组不存在中心下标，返回 `-1`

### 示例

**示例 1：**
```
输入：nums = [1, 7, 3, 6, 5, 6]
输出：3
解释：
中心下标是 3
左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11
右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11，二者相等
```

**示例 2：**
```
输入：nums = [1, 2, 3]
输出：-1
解释：数组中不存在满足此条件的中心下标
```

## 解决方案

本项目提供了 **4种不同的实现方法**，从暴力解法到最优解，展示了算法优化的完整过程：

### 1. 暴力解法

```javascript
function findMiddleIndexBruteForce(nums) {
    for (let i = 0; i < nums.length; i++) {
        let leftSum = 0, rightSum = 0;
        
        // 计算左侧元素和
        for (let j = 0; j < i; j++) {
            leftSum += nums[j];
        }
        
        // 计算右侧元素和
        for (let k = i + 1; k < nums.length; k++) {
            rightSum += nums[k];
        }
        
        if (leftSum === rightSum) {
            return i;
        }
    }
    return -1;
}
```

**算法特点：**
- **时间复杂度：** O(n²) - 对每个位置都要重新计算左右两侧的和
- **空间复杂度：** O(1) - 只使用常数额外空间
- **优点：** 思路直观，易于理解
- **缺点：** 存在大量重复计算，效率较低

**适用场景：**
- 算法学习和理解
- 小规模数据处理
- 面试中展示基础思路

### 2. 前缀和优化解法

```javascript
function findMiddleIndexPrefixSum(nums) {
    const n = nums.length;
    const prefixSum = new Array(n + 1).fill(0);
    
    // 构建前缀和数组
    for (let i = 0; i < n; i++) {
        prefixSum[i + 1] = prefixSum[i] + nums[i];
    }
    
    // 查找中心索引
    for (let i = 0; i < n; i++) {
        const leftSum = prefixSum[i];
        const rightSum = prefixSum[n] - prefixSum[i + 1];
        
        if (leftSum === rightSum) {
            return i;
        }
    }
    return -1;
}
```

**算法特点：**
- **时间复杂度：** O(n) - 两次遍历，一次构建前缀和，一次查找
- **空间复杂度：** O(n) - 需要额外的前缀和数组
- **优点：** 避免重复计算，查找阶段效率高
- **缺点：** 需要额外空间存储前缀和

**适用场景：**
- 需要多次查询的场景
- 对时间复杂度有要求但空间充足的情况
- 展示前缀和数据结构的应用

### 3. 一次遍历解法（最优解）

```javascript
function findMiddleIndexOptimal(nums) {
    const totalSum = nums.reduce((sum, num) => sum + num, 0);
    let leftSum = 0;
    
    for (let i = 0; i < nums.length; i++) {
        // 利用数学关系：leftSum * 2 + nums[i] === totalSum
        if (leftSum * 2 + nums[i] === totalSum) {
            return i;
        }
        leftSum += nums[i];
    }
    return -1;
}
```

**算法特点：**
- **时间复杂度：** O(n) - 只需要两次遍历（一次求总和，一次查找）
- **空间复杂度：** O(1) - 只使用常数额外空间
- **优点：** 时间和空间复杂度都是最优的
- **核心思想：** 利用数学关系 `leftSum = rightSum` 推导出 `leftSum * 2 + nums[i] = totalSum`

**适用场景：**
- 生产环境推荐使用
- 对性能要求较高的场景
- 算法竞赛和面试的最优解

### 4. 数学优化解法

```javascript
function findMiddleIndexMath(nums) {
    const totalSum = nums.reduce((sum, num) => sum + num, 0);
    let leftSum = 0;
    
    for (let i = 0; i < nums.length; i++) {
        const rightSum = totalSum - leftSum - nums[i];
        
        if (leftSum === rightSum) {
            return i;
        }
        leftSum += nums[i];
    }
    return -1;
}
```

**算法特点：**
- **时间复杂度：** O(n)
- **空间复杂度：** O(1)
- **优点：** 逻辑清晰，直接计算右侧和进行比较
- **思路：** 直接利用 `rightSum = totalSum - leftSum - nums[i]` 的关系

## 核心算法原理

### 数学推导

设数组为 `nums`，中心索引为 `i`，则有：

```
leftSum = nums[0] + nums[1] + ... + nums[i-1]
rightSum = nums[i+1] + nums[i+2] + ... + nums[n-1]
totalSum = nums[0] + nums[1] + ... + nums[n-1]
```

当 `leftSum = rightSum` 时，`i` 为中心索引。

**关键推导：**
```
leftSum = rightSum
leftSum = totalSum - leftSum - nums[i]
2 * leftSum = totalSum - nums[i]
leftSum * 2 + nums[i] = totalSum
```

这个数学关系是最优解法的核心。

### 边界情况处理

1. **空数组：** 返回 `-1`
2. **单元素数组：** 返回 `0`（左右两侧和都为0）
3. **全零数组：** 返回 `0`（所有位置都是中心索引，返回最左边的）
4. **负数数组：** 正常处理，算法支持负数

## 测试结果分析

### 功能测试

所有4种实现都通过了以下测试用例：

| 测试用例 | 输入 | 期望输出 | 实际输出 | 状态 |
|---------|------|----------|----------|------|
| 基础测试 | `[1, 7, 3, 6, 5, 6]` | `3` | `3` | ✅ |
| 无中心索引 | `[1, 2, 3]` | `-1` | `-1` | ✅ |
| 左端中心 | `[2, 1, -1]` | `0` | `0` | ✅ |
| 单元素 | `[1]` | `0` | `0` | ✅ |
| 空数组 | `[]` | `-1` | `-1` | ✅ |
| 全零数组 | `[0, 0, 0]` | `0` | `0` | ✅ |
| 负数数组 | `[-1, -1, -1, 0, 1, 1]` | `0` | `0` | ✅ |
| 中间中心 | `[1, 0, 1]` | `1` | `1` | ✅ |

### 性能测试结果

在1000次迭代测试中：

| 实现方法 | 数组大小 | 执行时间 | 性能排名 | 备注 |
|---------|---------|---------|----------|------|
| 数学优化解法 | 10,000 | 18.748ms | 🥇 最快 | 推荐生产使用 |
| 一次遍历解法 | 10,000 | 19.636ms | 🥈 第二 | 最优解 |
| 前缀和解法 | 10,000 | 58.716ms | 🥉 第三 | 空间换时间 |
| 暴力解法 | 100 | 14.11ms | 第四 | 仅适合小数组 |

**性能分析：**
- **数学优化解法**和**一次遍历解法**性能相近，都是最优的O(n)时间复杂度
- **前缀和解法**虽然也是O(n)，但常数因子较大，且需要额外空间
- **暴力解法**在大数组上性能急剧下降，不适合生产环境

## 使用建议

### 生产环境推荐

**首选：一次遍历解法（findMiddleIndexOptimal）**
- 时间复杂度最优：O(n)
- 空间复杂度最优：O(1)
- 代码简洁，易于维护

**备选：数学优化解法（findMiddleIndexMath）**
- 性能略优于一次遍历解法
- 逻辑更直观，易于理解

### 学习和面试推荐

**推荐顺序：**
1. **暴力解法** - 展示基础思路
2. **前缀和解法** - 展示优化思维
3. **一次遍历解法** - 展示最优解

### 特殊场景推荐

- **多次查询场景：** 前缀和解法
- **内存受限场景：** 一次遍历解法
- **教学演示场景：** 暴力解法 → 前缀和解法 → 最优解法

## 算法扩展

### 相关问题

1. **LeetCode 724 - 寻找数组的中心索引**（与本题完全相同）
2. **数组分割问题**
3. **子数组和问题**

### 优化方向

1. **并行计算：** 对于超大数组，可以考虑并行计算总和
2. **流式处理：** 对于流式数据，可以维护动态的左右两侧和
3. **多中心索引：** 返回所有中心索引而不是第一个

### 实际应用场景

1. **负载均衡：** 在分布式系统中找到负载平衡点
2. **数据分析：** 在数据序列中找到平衡点
3. **游戏开发：** 在游戏中计算重心或平衡点
4. **物理模拟：** 计算质心或重心位置

## 总结

本实现提供了从暴力解法到最优解的完整算法演进过程，展示了：

- **算法优化思路：** 从O(n²)到O(n)的优化过程
- **空间时间权衡：** 不同解法在时间和空间复杂度上的取舍
- **数学建模能力：** 将问题转化为数学关系的能力
- **工程实践价值：** 在实际项目中的应用指导

推荐在生产环境中使用**一次遍历解法**，在学习和面试中展示完整的优化思路。